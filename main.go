package main

import "fmt"

// Канал — это объект связи, с помощью которого горутины обмениваются данными.
// То есть одна горутина может отправить данные в канал, а другая — считать помещенные в этот канал данные.
// В go каналы являются указателями. В большинстве своем, когда вам необходимо взаимодействовать с горутиной, вы помещаете канал как аргумент в функцию или метод.
// Сохранить значение в канал -
//    var data int
//    data = <- c
// !!!! Все вышеобозначенные операции с каналом являются блокируемыми.
//Когда вы помещаете данные в канал, горутина блокируется до тех пор,
//пока данные не будут считаны другой горутиной из этого канала.
//В то же время операции канала говорят планировщику о планировании другой горутины,
//поэтому программа не будет заблокирована полностью. Эти функции весьма полезны,
//так как отпадает необходимость писать блокировки для взаимодействия горутин.

func main() {
	//Initilazation()
	//ChannelOnPractice()
	//DeadlockAndReciprcoal()
	//ClosingChannel()
	ChannelsProfi()

}

func ChannelsProfi() {
	fmt.Println("main begin")
	willClose := make(chan int, 3)
	willClose <- -1
	willClose <- 0
	willClose <- 2
	<-willClose
	<-willClose
	<-willClose
	<-willClose

	close(willClose)
	read := <-willClose
	fmt.Println(read)
}

func Initilazation() {
	var c chan int // Вы не можете передать или получить данные из канала, так как он не был создан (инициализирован).

	fmt.Printf("type of `c` is %T\n", c)
	fmt.Printf("value of `c` is %v\n", c)
	fmt.Println()

	cm := make(chan int)
	fmt.Printf("type of `c` is %T\n", cm)
	fmt.Printf("value of `c` is %v\n", cm)
}

func greet(c chan string) {
	fmt.Println("Hello " + <-c + "!")
}

func ChannelOnPractice() {
	fmt.Println()

	fmt.Println("main() started")
	c := make(chan string)

	go greet(c)

	c <- "John"
	fmt.Println("main() stopped")

	// 1. Мы объявили функцию greet, которая принимает канал c как аргумент. В этой функции мы считываем данные из канала c и выводим в консоль.
	// 2. В функции main программа сначала выводит "main() started".
	// 3. Затем мы, используя make, создаем канал c с типом даных string
	// 4. Помещаем канал с в функцию greet и запускаем функцию как горутину, используя ключевое слово go.
	// 5. Теперь у нас имеется две горутины main и greet, main по-прежнему остается активной.
	// 6. Помещаем данные в канал с и в этот момент main блокируется до тех пор, пока другая горутина (greet) не считает данные из канала c.
	//      Планировщик Go планирует запуск greet и выполняет описанное в первом пункте.
	// 7. После чего main снова становится активной и выводит в консоль "main() stopped".
}

func DeadlockAndReciprcoal() {
	// Чтение или запись данных в канал блокирует горутину и контроль передается свободной горутине
	// | Если вы попытаетесь считать данные из канала, но в канале будут отсутствовать данные,
	// | планировщик заблокирует текущую горутину и разблокирует другую в надежде, что какая-либо горутина передаст данные в канал.
	// | То же самое произойдет в случае отправки данных: планировщик заблокирует передающую горутину, пока другая не считает данные из канала.

	// Примером deadlock может быть main горутина, которая эксклюзивно производит операции с каналом.
	fmt.Println("main() started")

	c := make(chan string)
	c <- "John"

	fmt.Println("main() stopped")
	// будет fatal error: all goroutines are asleep - deadlock!
}

func ClosingChannel() {
	// В Go так же можно закрыть канал, через закрытый канал невозможно будет передать или принять данные.
	//val, ok := <- channel, где ok будет истиной в случае, если канал открыт или операция чтения может быть выполнена,
	//иначе ok будет false, если канал закрыт и отсутствуют данных для чтения из него.
	//Закрыть канал можно, используя встроенную функцию close, используя следующий синтаксис close(channel)

	fmt.Println("main() started")

	c := make(chan string, 1)

	go greet(c)
	c <- "John"

	close(c) // closing channel

	c <- "Mike"
	fmt.Println("main() stopped")
	// panic: send on closed channel
	// Как вы можете заметить, программа завершилась с ошибкой, которая говорит, что запись в закрытый канал невозможна.

	// | Для понимания концепта блокировки первая операция отправки c <- "John" будет блокирующей, и другая горутина
	// | должна будет считать данные из канала, следовательно greet горутина будет запланирована планировщиком.
	// | Затем первая операция чтения будет неблокируемой, поскольку присутствуют данные для чтения в канале c.
	// | Вторая операция чтения будет блокируемой, потому что в канале c отсутствуют данные, поэтому планировщик
	// | переключится на main горутину и программа выполнит закрытие канала close(c).
}

func squares(c chan int) {
	for i := 0; i <= 9; i++ {
		c <- i * i
	}

	close(c) // close channel
}

func CycleFor() {
	//  Для дальнейшего понимания закрытия каналов давайте рассмотрим пример с циклом for.

	fmt.Println("main() started")
	c := make(chan int)

	go squares(c) // start goroutine

	// periodic block/unblock of main goroutine until chanel closes
	for {
		val, ok := <-c
		if ok == false {
			fmt.Println(val, ok, "<-- loop broke!")
			break // exit break loop
		} else {
			fmt.Println(val, ok)
		}
	}

	fmt.Println("main() stopped")
	// Бесконечный цикл может быть полезен для чтения данных из канала, когда мы не знаем сколько данных мы ожидаем.
	//В этом примере мы создаем горутину squares, которая последовательно возвращает квадраты чисел от 0 до 9.
	//В main мы считываем эти числа внутри цикла for.
	// ok предоставляет нам информацию о том, что канал закрыт.

	// В цикле мы считываем данные из канала, используя ранее рассмотренный синтаксис val, ok := <-c, где ok предоставляет нам информацию о том, что канал закрыт.
	//В горутине squares после того, как записали все данные, мы закрываем канал, используя функцию close.
	//Когда ok будет true, программа выведет значение val и статус канала (переменная ok). Когда ok станет false,
	//мы завершим цикл, используя ключевое слово break. Таким образом мы получим следующий результат:
	// main() started
	//0 true
	//1 true
	//4 true
	//9 true
	//16 true
	//25 true
	//36 true
	//49 true
	//64 true
	//81 true
	//0 false <-- loop broke!
	//main() stopped

	// Когда канал закрыт, значение val, считанное горутиной, является нулевым значением, в зависимости от типа данных канала.
	//Так как в нашем случае тип данных канала int, то нулевое значение будет 0, как раз это мы и видим в этой строке: 0 false <-- loop broke!
}

func CycleForWithRange() {
	// Для того, чтобы избежать столь громоздкой проверки закрытия канала в случае цикла for,
	//Go предоставляет ключевое слово range, которое автоматически останавливает цикл,
	//когда канал будет закрыт. Давайте перепишем нашу программу с использованием range:

	fmt.Println("main() started")
	c := make(chan int)

	go squares(c) // start goroutine

	// periodic block/unblock of main goroutine until chanel closes
	for val := range c {
		fmt.Println(val)
	}

	fmt.Println("main() stopped")

	// В этом примере мы использовали val := range c вместо бесконечного цикла, где range будет считывать данные
	// из канала до тех пор, пока канал не будет закрыт. В результате программа выведет следующее:
	// main() started
	//0
	//1
	//4
	//9
	//16
	//25
	//36
	//49
	//64
	//81
	//main() stopped

	// | Если вы не закроете канал для цикла for с использованием range,
	// | то программа будет завершена аварийно из-за dealock во время выполнения.
}
